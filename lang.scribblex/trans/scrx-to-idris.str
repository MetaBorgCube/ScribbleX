module scrx-to-idris

imports
  signatures/ScribbleX-sig
  pp
  signatures/Idris-sig
  scribblex

signature
  
  sorts PayloadKind constructors // used for case analysis on payload in result types
    SimpleType    : Expr -> PayloadKind
    SingletonDecl : ID * Expr -> PayloadKind
    SingletonRef  : ID * Expr -> PayloadKind

  sorts FIXME constructors
    FIXME : FIXME

rules

  test-local-to-idris:
    mod -> result
    with
      ( <strip-annos; scrx-to-idris; pp-ScribbleX-string> mod
      ; result := SUCCEEDS())
      <+ result := FAILS()

  scrx-to-idris:
    Module(mname, protocol@Local(_, roles, _)) ->
      <trans-protocol> protocol
    where // initialize counters used for fresh names
      <new-counter> "S"
    ; <new-counter> "payloadId"
    ; <foldr(!(),
        \ (Role(x), _) ->
            <concat-strings; new-counter> ["choice_", x] \)>
        roles

rules

  trans-protocol:
    Local(pname, roles, interaction) ->
      IdrisModule(
        [Data("State", states')|choices'],
        Interface(pname, [Param("m", ArrowT(<mk-type-id> "Type", <mk-type-id> "Type"))],
          signatures'))
    where
      (signatures', states', choices', _) :=
      <trans-maybe-interaction> 
        (pname,
         interaction,
         [],
         [Sig("StateT", ArrowT(<mk-type-id> "State", <mk-type-id> "Type")),
          Sig("start", <mk-strans-nobr> (Id("Var"), NilL(), 
                                         Brack(Fun("l", List([STCons(Id("l"), App(Id("StateT"), Id("Ready")))])))))],
         [K("Ready", None(), "State", [])],
         [],
         Id("Ready"))
     
rules

  trans-maybe-interaction:
    (pname, None(), ctx, signatures, states, choices, prev-state) ->
      (signatures, states, choices, None())
  
  trans-maybe-interaction:
    (pname, Some(i), ctx, signatures, states, choices, prev-state) ->
      <trans-interaction>
        (pname, i, ctx, signatures, states, choices, prev-state)
      
rules
  
  trans-interaction:
    (pname,
     From(msg, payload, from-role, opt-cont),
     ctx, signatures, states, choices, prev-state) ->
      (signatures', states', choices', Some((new-state, tys)))
      where
        (tys, ctx') :=
          <foldr(!([], []),
                 { ctx'', ty' :
                 \ (pl, (tys', ctx')) ->
                     ([ty'|tys'], <concat> [ctx'', ctx'])
                   where 
                     (ty', ctx'') :=
                       <trans-rcv-payload> (pl, <concat> [ctx, ctx']) \ })> payload
      ; (state', new-state) := <concat; new-state> [ctx, ctx']
      ; sig :=
          Sig(msg,
            PiTBr("l", <mk-type-id> "Var",
              <mk-strans>
                (<payload-types-to-return-types> tys,
                 List([STCons(Id("l"), App(Id("StateT"), prev-state))]),
                 <generalize-rcv-result> (new-state, tys))))
      ; (signatures', states', choices', _) :=
          <trans-maybe-interaction> 
            (pname,
             opt-cont,
             <concat> [ctx, ctx'],
             <concat> [signatures, [sig]],
             <concat> [states, [state']],
             choices,
             new-state)
  
  trans-interaction:
    (pname,
     To(msg, payload, from-role, opt-cont),
     ctx, signatures, states, choices, prev-state) ->
      (signatures', states', choices', Some((new-state, tys)))
    where
      (tys, ctx') :=
        <foldr(!([], []),
               { ctx'', ty' :
               \ (pl, (tys', ctx')) ->
                   ([ty'|tys'], <concat> [ctx'', ctx'])
                 where
                   (ty', ctx'') :=
                     <trans-snd-payload> (pl, <concat> [ctx, ctx']) \ })> payload
    ; (state', new-state) := <concat; new-state> [ctx, ctx']
    ; sig :=
        Sig(msg,
            <parameterize-by-payloads> 
              (<mk-strans>
                 (Unit(),
                  List([STCons(Id("l"), App(Id("StateT"), prev-state))]),
                  Brack(App(Id("const"),
                    List([STCons(Id("l"), App(Id("StateT"), new-state))])))),
               tys))
    ; (signatures', states', choices', _) :=
        <trans-maybe-interaction> 
          (pname,
           opt-cont,
           <concat> [ctx, ctx'],
           <concat> [signatures, [sig]],
           <concat> [states, [state']],
           choices,
           new-state)

  trans-interaction: // FIXME: handle case where interaction branches are none
    (pname,
     Choice(role, Some(interaction), or-choices),
     ctx, signatures, states, choices, prev-state) ->
      (<concat> [signatures, [sig], signatures1],
       <concat> [states, states1],
       [choice|<concat> [choices, choices1]],
       None())
    where
      <string-tokenize(|['_']); last> pname := role // local choice
    ; (signatures0, states0, choices0, Some(new-state0)) :=
        <trans-branch>
          (pname,
           interaction,
           ctx, signatures, states, choices, prev-state)
    ; (signatures1, states1, choices1, new-states) :=
        <foldr(!(signatures0, states0, choices0, [new-state0]),
          { signatures'', states'', choices'', new-state'' :
          \ (Or(Some(i)), (signatures', states', choices', new-states')) ->
              (<conc> (signatures', signatures''),
               <conc> (states', states''),
               <conc> (choices', choices''),
               <conc> (new-states', [new-state'']))
            where
              debug
            ; (signatures'', states'', choices'', Some(new-state'')) :=
                <trans-branch>
                  (pname,
                   i,
                   ctx, signatures, states, choices, prev-state) \ })>
          or-choices
    ; sig-name-base := <concat-strings> ["choice_", role]
    ; postfix := <get-counter; int-to-string> sig-name-base
    ; sig-name := <concat-strings> [sig-name-base, postfix]
    ; choice-name := <concat-strings> ["Choice_", role, postfix]
    ; <next-counter> sig-name-base
    ; choice@Data(_, ks) := <new-choice> (choice-name, new-states)
    ; sig :=
        Sig(sig-name,
          PiT("l", <mk-type-id> "Var",
            PiTBr("choice", <mk-type-id> choice-name,
              <mk-strans>
                 (Unit(),
                    List([STCons(Id("l"), App(Id("StateT"), prev-state))]),
                    App(Id("const"),
                      List([STCons(Id("l"), App(Id("StateT"),
                        Brack(
                          Case(Id("choice"),
                            <zip; map(choice-case)> (ks, new-states)))))]))))))

  trans-interaction: // FIXME: handle case where interaction branches are none
    (pname,
     Choice(role, Some(interaction), or-choices),
     ctx, signatures, states, choices, prev-state) ->
      (<concat> [signatures, [sig], signatures1],
       <concat> [states, states1],
       [choice|<concat> [choices, choices1]],
       None())
    where
      not(<string-tokenize(|['_']); last> pname := role) // non-local choice
    ; (signatures0, states0, choices0, Some(new-state0)) :=
        <trans-branch>
          (pname,
           interaction,
           ctx, signatures, states, choices, prev-state)
    ; (signatures1, states1, choices1, new-states) :=
        <foldr(!(signatures0, states0, choices0, [new-state0]),
          { signatures'', states'', choices'', new-state'' :
          \ (Or(Some(i)), (signatures', states', choices', new-states')) ->
              (<conc> (signatures', signatures''),
               <conc> (states', states''),
               <conc> (choices', choices''),
               <conc> (new-states', [new-state'']))
            where
              debug
            ; (signatures'', states'', choices'', Some(new-state'')) :=
                <trans-branch>
                  (pname,
                   i,
                   ctx, signatures, states, choices, prev-state) \ })>
          or-choices
    ; sig-name-base := <concat-strings> ["choice_", role]
    ; postfix := <get-counter; int-to-string> sig-name-base
    ; sig-name := <concat-strings> [sig-name-base, postfix]
    ; choice-name := <concat-strings> ["Choice_", role, postfix]
    ; <next-counter> sig-name-base
    ; choice@Data(_, ks) := <new-choice> (choice-name, new-states)
    ; sig :=
        Sig(sig-name,
          PiTBr("l", <mk-type-id> "Var",
            <mk-strans>
               (Id(choice-name),
                  List([STCons(Id("l"), App(Id("StateT"), prev-state))]),
                  Brack(
                    FunBr("choice",
                      List([STCons(Id("l"), App(Id("StateT"),
                        Brack(
                          Case(Id("choice"),
                            <zip; map(choice-case)> (ks, new-states)))))]))))))

  choice-case:
    (K(choice-case-name, _, _, _),
     (new-state, tys)) ->
      Case(App(choice-case-name, <map(payload-to-id)> tys), new-state)
    where
      <reset-counter> "payloadId"

  payload-to-id:
    SingletonDecl(x, _) -> Id(x)
  
  payload-to-id:
    SimpleType(_) ->
      Id(<concat-strings> ["x", <get-counter; int-to-string> "payloadId"])
    where
      <next-counter> "payloadId"
      
  payload-to-id:
    SingletonRef(_, _) ->
      Id(<concat-strings> ["x", <get-counter; int-to-string> "payloadId"])
    where
      <next-counter> "payloadId"

rules // Translation of branch of conditional

  trans-branch: // Case 'To' followed by a recursive call
    (pname,
     To(msg, payload, from-role, Some(Continue(_))),
     ctx, signatures, states, choices, prev-state) ->
      FIXME()

  trans-branch: // Case 'From' followed by a recursive call
    (pname,
     From(msg, payload, from-role, Some(Continue(_))),
     ctx, signatures, states, choices, prev-state) ->
      FIXME()
  
  trans-branch: // Case 'To' followed by anything else than a recursive call
    (pname,
     To(msg, payload, from-role, opt-cont),
     ctx, signatures, states, choices, prev-state) ->
      (<diff> (signatures', signatures),
       <diff> (states', states),
       <diff> (choices', choices),
       Some((new-state, tys)))
    where
      not(Some(Continue(_)) := opt-cont)
    ; (tys, ctx') :=
        <foldr(!([], []),
               { ctx'', ty' :
               \ (pl, (tys', ctx')) ->
                   ([ty'|tys'], <concat> [ctx'', ctx'])
                 where
                   (ty', ctx'') :=
                     <trans-snd-payload> (pl, <concat> [ctx, ctx']) \ })> payload
    ; (state', new-state) := <concat; new-state> [ctx, ctx']
    ; (signatures', states', choices', _) :=
        <trans-maybe-interaction> 
          (pname,
           opt-cont,
           <concat> [ctx, ctx'],
           <concat> [signatures],
           <concat> [states, [state']],
           choices,
           new-state)

  trans-branch: // Case 'From' followed by anything else than a recursive call
    (pname,
     From(msg, payload, from-role, opt-cont),
     ctx, signatures, states, choices, prev-state) ->
      (<diff> (signatures', signatures),
       <diff> (states', states),
       <diff> (choices', choices),
       Some((new-state, tys)))
      where
        not(Some(Continue(_)) := opt-cont)
      ; (tys, ctx') :=
          <foldr(!([], []),
                 { ctx'', ty' :
                 \ (pl, (tys', ctx')) ->
                     ([ty'|tys'], <concat> [ctx'', ctx'])
                   where 
                     (ty', ctx'') :=
                       <trans-rcv-payload> (pl, <concat> [ctx, ctx']) \ })> payload
      ; (state', new-state) := <concat; new-state> [ctx, ctx']
      ; (signatures', states', choices', _) :=
          <trans-maybe-interaction> 
            (pname,
             opt-cont,
             <concat> [ctx, ctx'],
             <concat> [signatures],
             <concat> [states, [state']],
             choices,
             new-state)

rules // Translation of payload reception

  trans-rcv-payload:
    (Type(Int()), _) ->
      (SimpleType(Id("Int")), [])

  trans-rcv-payload:
    (Type(String()), _) ->
      (SimpleType(Id("String")), [])

  trans-rcv-payload: // FIXME: t should not be a reference to a singleton type
    (Ston(x, t), ctx) ->
      (SingletonDecl(x, ty'), [(x, ty')|ctx'])
    where
      (SimpleType(ty'), ctx') := <trans-rcv-payload> (Type(t), ctx)
    ; <new-counter> x
  
  trans-rcv-payload:
    (Type(Id(x)), ctx) ->
      (SimpleType(Brack(DPairT(new-x,
                                 <lookup> (x, ctx),
                                 Eq(Id(new-x), Id(x))))),
        [])
    where
      new-x := <concat-strings> [x, <get-counter; int-to-string> x]

rules // Translation of payload transmission

  trans-snd-payload:
    (Type(Int()), _) ->
      (SimpleType(Id("Int")), [])

  trans-snd-payload:
    (Type(String()), _) ->
      (SimpleType(Id("String")), [])

  trans-snd-payload: // assumption: cannot type a type variable by a singleton type
    (Ston(x, t), ctx) ->
      (SingletonDecl(x, ty'), [(x, ty')|ctx'])
    where
      (SimpleType(ty'), ctx') := <trans-snd-payload> (Type(t), ctx)
    ; <new-counter> x

  trans-snd-payload:
    (Type(Id(x)), ctx) ->
      (SingletonRef(x, <lookup> (x, ctx)), [])

rules // Generalize final state by variables being received; 'from' case

  generalize-rcv-result:
    (state, []) ->
      Brack(
        App(Id("const"), 
          List([STCons(Id("l"), App(Id("StateT"), state))])))
      
  generalize-rcv-result:
    (state, [SingletonDecl(x, _)]) ->
      Brack(
        Fun(x, 
          List([STCons(Id("l"), App(Id("StateT"), state))])))

  generalize-rcv-result:
    (state, [SimpleType(_)]) ->
      Brack(
        App(Id("const"), 
          List([STCons(Id("l"), App(Id("StateT"), state))])))
  
  generalize-rcv-result:
    (state, tys) ->
      Brack(
        FunBr("r",
          List([STCons(Id("l"), App(Id("StateT"),
            Brack(
              Case(Id("r"),
                [Case(Brack(Tuple(<map(ty-to-pat)> tys)), state)]))))])))
  
  ty-to-pat:
    SingletonDecl(x, _) -> Id(x)

  ty-to-pat:
    SingletonRef(_, _) -> Id("_")

  ty-to-pat:
    SimpleType(_) -> Id("_")

rules // Parameterize command by payload being sent; 'to' case

  parameterize-by-payloads:
    (trans, []) ->
      PiTBr("l", <mk-type-id> "Var", trans)
      
      
  parameterize-by-payloads:
    (trans, tys@[_|_]) ->
      PiT("l", <mk-type-id> "Var",
        <init;
         foldr(!<parameterize-by-payload-br> (<last> tys, trans),
               parameterize-by-payload)> tys)

  parameterize-by-payload-br:
    (SimpleType(ty), trans) ->
      ArrowTBr(ExprT(ty), trans)
      
  parameterize-by-payload-br:
    (SingletonRef(x, ty), trans) ->
      PiTBr(x, ExprT(ty), trans)

  parameterize-by-payload-br:
    (SingletonDecl(x, ty), trans) ->
      PiTBr(x, ExprT(ty), trans)

  parameterize-by-payload:
    (SimpleType(ty), trans) ->
      ArrowT(ExprT(ty), trans)
      
  parameterize-by-payload:
    (SingletonDecl(x, ty), trans) ->
      PiT(x, ExprT(ty), trans)

  parameterize-by-payload:
    (SingletonRef(x, ty), trans) ->
      PiT(x, ExprT(ty), trans)

  unpack:
    SimpleType(ty) -> ty
  
  unpack:
    SingletonDecl(_, ty) -> ty

  unpack:
    SingletonRef(_, ty) -> ty

rules

  payload-types-to-return-types:
    [] -> Unit()
  
  payload-types-to-return-types:
    [ty] -> <unpack> ty
  
  payload-types-to-return-types:
    tys@[_|[_|_]] ->
      Brack(<init;
             foldr(!<last; unpack> tys, 
                   \ (ty, prod) -> Pair(<unpack> ty, prod) \)> tys)

rules // State constructor and name

  new-state:
    ctx ->
      (K(state-name,
         <parameterize-by-ctx> ctx,
         "State",
         []),
       <foldl(\ ((x , t), st) -> App(st, Id(x)) \); 
        brack-if-needed(|ctx)> (ctx, Id(state-name)))
    where
      state-name := <mk-state-id> ()

  mk-state-id:
    () -> <concat-strings> ["S", <get-counter; int-to-string> "S"]
    with
      <next-counter> "S"

rules // Choice constructor and name

  new-choice:
    (choice-name, new-states) ->
      Data(choice-name,
        <map(
          { choice-case-name :
          \ (_, tys) ->
              K(choice-case-name, <parameterize-by-payloads> tys, choice-name, [])
            where
              choice-case-name := <mk-choice-id> () \ })> new-states)
    where
      debug(!"asd")
    ; <new-counter> "C"

  mk-choice-id:
    () -> <concat-strings> ["C", <get-counter; int-to-string> "C"]
    with
      <next-counter> "C"

rules // Parameterize a data type by a context of singletons

  parameterize-by-ctx:
    [] -> None()
  
  parameterize-by-ctx:
    ctx@[_|_] ->
      Some(<map(\ (x, t) -> NamedParam(Param(x, ExprT(t))) \)> ctx)

rules // Parameterize a data type by a list of singletons

  parameterize-by-payloads:
    [] -> None()
  
  parameterize-by-payloads:
    tys@[_|_] ->
      Some(<map(payload-to-param)> tys)
  
  payload-to-param:
    SingletonDecl(x, t) -> NamedParam(Param(x, ExprT(t)))
  
  payload-to-param:
    SimpleType(t) -> Param(ExprT(t))
  
  payload-to-param:
    SingletonRef(x, t) -> NamedParam(Param(x, ExprT(t)))

rules // Helpers

  mk-type-id:
    x -> ExprT(Id(x))
  
  mk-strans:
    (return-type, pre-state, post-state) ->
      ExprT(AppBr(AppBr(App(App(Id("STrans"), Id("m")), return-type), pre-state), post-state))

  mk-strans-nobr: // no AppBr for layout
    (return-type, pre-state, post-state) ->
      ExprT(App(App(App(App(Id("STrans"), Id("m")), return-type), pre-state), post-state))


  brack-if-needed(|ctx):
    t -> Brack(t)
    where
      [_|_] := ctx
  
  brack-if-needed(|ctx):
    t -> t
    where
      [] := ctx